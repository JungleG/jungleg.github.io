---
layout: post
title: "Java线程状态"
date: 2017-09-27 09:00:00 +0800
categories: 研究生涯
tag: java
---  
* content
{:toc}

现在的操作系统是多任务操作系统。多线程是实现多任务的一种方式。

进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程。比如在Windows系统中，一个运行的exe就是一个进程。 

线程是指进程中的一个执行流程，一个进程中可以运行多个线程。比如java.exe进程中可以运行很多线程。线程总是属于某个进程，进程中的多个线程共享进程的内存。

<!-- more -->

## Java中的线程的生命周期大体可分为5种状态。

### 1. 新建(NEW)

新创建了一个线程对象。

### 2. 可运行(RUNNABLE)

线程对象创建后，其他线程(如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。

### 3. 运行(RUNNING)

可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。

### 4. 阻塞(BLOCKED)

阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： 

>等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。
>同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。
>其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。

### 5. 死亡(DEAD)

线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。

![](https://ooo.0o0.ooo/2017/09/27/59cb4bef0e81c.jpg){:height="80%" width="80%"}

---
## 注

### sleep()和wait()的区别

（1）两个方法来自不同的类，sleep来自Thread类，wait来自Object类
（2）sleep方法没有释放锁，wait方法释放了锁，使得其他线程可以使用同步控制块或者方法
（3）sleep不出让系统资源；wait是进入线程等待池等待，出让系统资源，其他线程可以占用CPU。一般wait不会加时间限制，应为如果wait线程的运行资源不够，出来也没有用，要等待其他线程调用notify/notifyAll唤醒等待池中的所有线程，才会进入就绪队列等待OS分配系统资源。sleep(milliseconds)可以用时间指定使它自动唤醒出来，如果时间不到只能调用interrupt()强行打断。
Thread.sleep(0)的作用是“触发操作系统立刻重新进行一次CPU竞争”
（4）使用范围：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用。

### 抢占式

Java中的多线程是一种抢占式的机制，而不是分时机制。抢占式的机制是有多个线程处于可运行状态，但是只有一个线程在运行。
